# inpt = "12 VJWQR, 1 QTBC => 6 BGXJV
# 12 BGTMN, 2 DRKQR => 2 TVSF
# 2 FTFK => 2 THNDN
# 13 LKRTN, 7 MDPN, 12 NZKQZ => 5 LPWPD
# 1 HDKX, 3 DWZS, 1 RCBQS => 1 DCRK
# 14 ZCMF => 6 ZKHLC
# 3 ZFVH, 2 ZCMF, 1 SCJG, 1 LQWJ, 4 BGBJ, 1 NHPR, 3 VKZFJ, 7 FWFXZ => 4 QVJMP
# 11 TNMLB => 7 NVDCR
# 1 LPWPD, 1 BGBJ => 2 SCJG
# 3 DFCVF, 1 QGSN => 6 PQXG
# 1 BGXJV, 1 THNDN => 4 BCQN
# 3 LKRTN => 9 MDPN
# 2 THNDN, 13 RCKZ, 10 FQSLN => 8 VKZFJ
# 4 LBCZ, 9 LWHS => 1 FQSLN
# 6 WSRVZ => 9 TNMLB
# 8 FQSLN, 14 JQRF, 4 BGTMN => 5 QGSN
# 4 ZCMF, 4 PLSM, 2 ZHTX => 8 TDHPM
# 2 RSKC, 10 SHBC, 8 MDPN => 6 FMSZ
# 2 VJWQR => 2 FPTV
# 12 DRKQR => 6 NHPR
# 35 QJLF, 22 BGTMN, 11 VJWTR, 1 QVJMP, 8 LQWJ, 1 TWLC, 16 NXZCH, 18 THKF, 42 JBLM => 1 FUEL
# 2 BGTMN, 4 XJKN => 8 ZCMF
# 4 TVSF => 3 RSKC
# 7 HRWS, 1 TVSF => 3 ZHTX
# 134 ORE => 4 WSRVZ
# 1 VKZFJ, 1 TWLC, 4 ZHTX, 5 THNDN, 12 PLVN, 1 ZFXNP, 1 PQXG, 6 CWHV => 7 VJWTR
# 20 XJKN, 1 LCKW, 3 NZKQZ => 7 HDKX
# 1 LPWPD => 8 RCKZ
# 4 RCBQS, 1 NVDCR => 5 BGBJ
# 8 BGXJV => 4 BGTMN
# 13 QBDX, 16 BGXJV => 6 NZKQZ
# 2 LPWPD => 3 DRKQR
# 4 QBDX => 7 XJKN
# 12 LCKW, 9 NVDCR => 3 RCBQS
# 142 ORE => 3 QBDX
# 1 WXHJF => 1 XKDJ
# 2 RSKC => 2 CWHV
# 2 ZHTX, 1 ZFXNP => 6 JQRF
# 1 FTFK, 1 TVSF, 1 QBDX => 2 JBLM
# 1 TDHPM, 14 NHPR, 3 QPSF => 5 ZFVH
# 3 GDTPC, 1 ZKHLC => 8 ZFXNP
# 5 DWZS => 3 LQWJ
# 1 FTFK, 4 LBCZ, 13 NHPR => 1 FWFXZ
# 1 RCBQS, 12 SHBC => 9 FTFK
# 1 WSRVZ, 1 XKDJ => 5 LKRTN
# 2 BGTMN, 1 MDPN => 5 PLSM
# 2 BGXJV, 17 XKDJ, 4 FPTV => 9 LCKW
# 148 ORE => 2 QTBC
# 110 ORE => 2 VJWQR
# 42 ZFXNP, 15 RCKZ, 8 GDTPC => 3 QJLF
# 13 HRWS => 4 GDTPC
# 34 HRWS => 4 DFCVF
# 2 VKZFJ, 2 NHPR, 16 PLVN, 1 QPSF, 13 LBCZ, 4 DCRK, 10 LWHS => 7 NXZCH
# 3 CWHV, 1 THNDN => 7 LWHS
# 1 BGXJV, 2 QBDX => 5 DWZS
# 9 LQWJ => 8 QPSF
# 21 BCQN, 3 FMSZ, 1 RSKC => 5 THKF
# 118 ORE => 6 WXHJF
# 11 FMSZ => 9 TWLC
# 28 PLSM => 5 SHBC
# 1 ZKHLC, 23 SCJG => 7 LBCZ
# 17 DWZS, 16 THNDN => 9 PLVN
# 7 HDKX => 9 HRWS"

 inpt = "2 VPVL, 7 FWMGM, 2 CXFTF, 11 MNCFX => 1 STKFG
17 NVRVD, 3 JNWZP => 8 VPVL
53 STKFG, 6 MNCFX, 46 VJHF, 81 HVMC, 68 CXFTF, 25 GNMV => 1 FUEL
22 VJHF, 37 MNCFX => 5 FWMGM
139 ORE => 4 NVRVD
144 ORE => 7 JNWZP
5 MNCFX, 7 RFSQX, 2 FWMGM, 2 VPVL, 19 CXFTF => 3 HVMC
5 VJHF, 7 MNCFX, 9 VPVL, 37 CXFTF => 6 GNMV
145 ORE => 6 MNCFX
1 NVRVD => 8 CXFTF
1 VJHF, 6 MNCFX => 4 RFSQX
176 ORE => 6 VJHF"

struct reaction
    product::Array{Any, 1}
    educt::Array{Array{Any, 1}, 1}
end

# function getNeeded(reaction, reactionList)
#     needed = []
#     append!(needed, reaction.educt)
#     return needed
# end
#
# function getOreRecipes(reactionList)
#     oreRecipes = []
#     for r = reactionList
#         r.educt
#     end
# end

function unify(listOfChemicals)
    tmp = []
    for c = listOfChemicals
        found = false
        for t = 1:length(tmp)
            if c[1] == tmp[t][1]
                tmp[t] = [tmp[t][1], (tmp[t][2] + c[2])]
                found = true
            elseif c[2] == 0
                found = true
            end
        end
        found == false && push!(tmp, c)
    end
    return tmp
end



listOfReactions = split(inpt, "\n")

arrayOfReactions = []

for r = listOfReactions
    ingredients = split(r, " => ")
    educts = []
    for e = split(ingredients[1], ", ")
        push!(educts, [split(e, " ")[2], parse(Float64, split(e, " ")[1])])
    end
    push!(arrayOfReactions, reaction([split(ingredients[2], " ")[2], parse(Float64, split(ingredients[2], " ")[1])], educts))
end

neededforFuel = []

for r = arrayOfReactions
    if r.product[1] == "FUEL"
        append!(neededforFuel, r.educt)
        unify(neededforFuel)
        # println(needed)
    end
end

leftover = []
i = 1
# Ore = 1000000000000
# durchschnitt = []
# while Ore >= 0
#     needed = neededforFuel
#     while length(needed) > 1
#         newNeeded = []
#         for n = needed
#
#             if n[1] == "ORE"
#                 append!(newNeeded, [n])
#                 # println(newNeeded)
#                 newNeeded = unify(newNeeded)
#             else
#
#             enoughLeftOver = false
#
#             for l = 1:length(leftover)
#                 if n[1] == leftover[l][1] && n[2] <= leftover[l][2]
#                     enoughLeftOver = true
#                     global leftover[l][2] -= n[2]
#                 end
#                 if n[1] == leftover[l][1] && n[2] > leftover[l][2]
#                     n[2] -= leftover[l][2]
#                     global leftover[l][2] = 0
#                 end
#             end
#
#             for r = arrayOfReactions
#                 if !enoughLeftOver
#                     if r.product[1] == n[1]
#                         amount = n[2]
#                         if (amount / r.product[2]) % 1 > 0.0
#                             relative = ceil(amount/r.product[2])
#                             # n[1] == "QJLF" && println(r.product)
#                             push!(leftover, [r.product[1], r.product[2]*relative - amount])
#                             global leftover = unify(leftover)
#                         else
#                             relative = amount / r.product[2]
#                         end
#                         for e = r.educt
#                             push!(newNeeded, [e[1], e[2]*relative])
#                         end
#                         # break
#                         newNeeded = unify(newNeeded)
#                     end
#                 end
#             end
#         end
#         end
#         needed = newNeeded
#     end
#     # println("Timre is $i, Ore needed is $needed")
#     global Ore -= needed[1][2]
#     global i += 1
#     # i % 100 == 0 && println("$Ore $i")
#     d = 0
#     push!(durchschnitt, needed[1][2])
#     for s = 1:length(durchschnitt)
#         d += durchschnitt[s]
#     end
#     i % 100 == 0 && println(d/length(durchschnitt))
#     # println(leftover)
# end
needed = neededforFuel
i = 1
while i <= 14
    newNeeded = []
    allOre = true
    for n = needed
        #
        if n[1] == "ORE"
            append!(newNeeded, [n])
            newNeeded = unify(newNeeded)
        end
        for r = arrayOfReactions
                if r.product[1] == n[1]
                    amount = n[2]
                    relative = amount / r.product[2]
                    for e = r.educt
                        push!(newNeeded, [e[1], e[2]*relative])
                    end
                end
        end
    end
    global i += 1
    global needed = unify(newNeeded)
end
println("\n", needed)

println(1000000000000/needed[1][2])
